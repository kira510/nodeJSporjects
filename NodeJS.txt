What is Node.js?
  Before node, JS could not be used as a general purpose language. Node uses V8 internally.
  Its a javascript runtime built on Chrome's V8 javascript engine. Hence we can now use JS outside of the
  browser to build webservers that can access the file system and the database.
  To conclude , node js helps us use JS on server side programming.

  Chrome and node cannot read the JS code so they send the code to V8 engine and get back the results
  which can be understood by them.

  V8 is written in C++ due to which chrome and node are written majorly in C++ for easy binding. So when you run
  something like document.querySelector on chrome, at runtime a C++ function does this job underneath.
  Similarly, fs.readFile or os.platform run in node.js will be run by some C++ function underneath at runtime.

  => node
    > *repl where you can run code (read eval print loop)*
    > window
    > global
    > document
    > process
    > process.exit()

  Window is not defined for node instead we have global, why is that?
  Cause chrome works with a window and node does not and similarly global is not defined on brower. So is document
  with chrome which is not defined on node.
  Similar to document, here we have process.

Why to Use nodejs?
    Nodejs uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.
    Node.js' package ecosystem , npm, is the largest ecosystem of open source libraries in the world.
      --> Non-blocking I/O: Any operation involving comunication with outside world are I/O operations like accessing the DB,
      the file syatem or getting some data from a server. What non-blocking I/O means that when nodejs is waitng for I/O
      operations, code execution can continue.
      --> Event-driven: Callbacks run after an event is complete or an event is fired, eg: I/O operations
      --> npm is node package manager, a tool that was installed when you installed node on your system. npm is the world's
      largest software registry.

Reading Command line data
  We always execute js files as node. So its basically command that you can optimise your js script to the way a shell script
  behaves, like give options, commands etc.
  Each command will have a set of options it needs and a handler.
        const yargs = require('yargs');
        console.log(process.argv)
        console.log(yargs.argv)

        OUTPUT-
          [ '/Users/kirankumar/.nvm/versions/node/v11.11.0/bin/node',
            '/Users/kirankumar/Documents/Tutorials/JS/NODE_JS/Andrew_mead/Project/notes-app/yargs',
            'read',
            '--title=hi' ]
          { _: [ 'read' ], title: 'hi', '$0': 'yargs' }

  As you can see in above code, we have process and yargs to get the command and options that were passed.

  PROCESS: The process object is a global that provides information about, and control over, the current Node.js process (https://nodejs.org/api/process.html)
  YARGS: A package that helps us parse the inputs , you can see above how it helps. If you use process then you must write your own parser.


DEBUGGING
  Its extremely simple,
    1. add a 'debugger' in your code
    2. run with inspect, which will open a debig console. "debug>"
            node inspect app.js add --title="wbdwehd" --body="third"
    3. Head over to chrome://inspect ,which opens the devices page and you know the rest.
    4. Also add the folder and give access to your folder in chrome to vide all the folder contents.
    6. After debugging, you can rerun the same debugger again.
            debug> restart
    7. Run (Ctrl + c) twice to end debugger.


Asynchronous Node.js (chapter 30)
    Call Stack, Node APIs, event loops ?
    JS is synchronous. Each line gets added to the call stack and gets executed, the asynchronous stuff like setTimout moves to the Node APIs
    stack whenre it starts executing in parallel (registering an event with Node APis).
    NODE APIS: DOM evnts, rest api calls, DB opearations
    After the event in  is complete, the node api pushed the completed result to event loop.
    Event loop each time checks if the call stack is empty, when its empty it will push the result from the callback queue to the call stack.
    Thats it.
    NOTE: Only after call stack is empty, the stuff in event loop gets executed.

REQUEST vs HTTP/HTTPS modules
    Why do we prefer to use external packages like request or axios or es6 fetch, casue this helps in request management very easy unlike the
    node.js HTTP or HTTPS module.
    In https module, response is received multiple times as abuffer and we must construct the data out of it. Too much code to write.

Hello Express JS
  1. Express JS
     Exports a function express that can be used to create an app.
          const app = express();
  2. app.use
     This works like app.get and also can be used to server static files.
          app.use(path, callbacks)
      It takes multiple callbacks that are expected sequetially unless you call next in one of them.
  3. express.static
     Method used to serve static files. It takes in a path which can be constructed using the path module exposed by nodejs.
          app.use(express.static(path.join(__dirname, '../public')));
      __dirname is a build in variable that gives present directory where it is run from.
      __filename : as simple as it is.
  4. app.listen
     It creates an http server that listens on the port you specify and takes a callbak function that gets called upon
     server creation.
  5. app.set
     This is usually used to set name to a value, set(name, value)
     ex:     app.set('view engine', hbs)
     This tells express that from now on it must use hbs to render from views. By default, hbs looks for the view files from
     the view folder in the home directory.
     Note that since we have added the static route, any path access within hbs file automatically looks for it in public folder.
     HBS is templating engine of handlebars for express.
